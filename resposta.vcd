$date
  Tue Jul 30 20:40:01 2019
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module fp_adder_testbench $end
$var reg 1 ! sign1 $end
$var reg 1 " sign2 $end
$var reg 4 # exp1[3:0] $end
$var reg 4 $ exp2[3:0] $end
$var reg 8 % frac1[7:0] $end
$var reg 8 & frac2[7:0] $end
$var reg 1 ' sign_out $end
$var reg 4 ( exp_out[3:0] $end
$var reg 8 ) frac_out[7:0] $end
$scope module fp_add_unit $end
$var reg 1 * sign1 $end
$var reg 1 + sign2 $end
$var reg 4 , exp1[3:0] $end
$var reg 4 - exp2[3:0] $end
$var reg 8 . frac1[7:0] $end
$var reg 8 / frac2[7:0] $end
$var reg 1 0 sign_out $end
$var reg 4 1 exp_out[3:0] $end
$var reg 8 2 frac_out[7:0] $end
$var reg 1 3 signb $end
$var reg 1 4 signs $end
$var reg 4 5 expb[3:0] $end
$var reg 4 6 exps[3:0] $end
$var reg 4 7 expn[3:0] $end
$var reg 8 8 fracb[7:0] $end
$var reg 8 9 fracs[7:0] $end
$var reg 8 : fraca[7:0] $end
$var reg 8 ; fracn[7:0] $end
$var reg 8 < sum_norm[7:0] $end
$var reg 4 = exp_diff[3:0] $end
$var reg 9 > sum[8:0] $end
$var reg 3 ? lead0[2:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
0!
0"
b0100 #
b0010 $
b10001000 %
b11100000 &
0'
b0100 (
b11000000 )
0*
0+
b0100 ,
b0010 -
b10001000 .
b11100000 /
00
b0100 1
b11000000 2
03
04
b0100 5
b0010 6
b0100 7
b10001000 8
b11100000 9
b00111000 :
b11000000 ;
b11000000 <
b0010 =
b011000000 >
b000 ?
#500000000
1"
b0011 (
b10100000 )
1+
b0011 1
b10100000 2
14
b0011 7
b10100000 ;
b10100000 <
b001010000 >
b001 ?
#1000000000
b0001 #
b0001 $
b11000000 %
b10000000 &
b0000 (
b10000000 )
b0001 ,
b0001 -
b11000000 .
b10000000 /
b0000 1
b10000000 2
b0001 5
b0001 6
b0000 7
b11000000 8
b10000000 9
b10000000 :
b10000000 ;
b10000000 <
b0000 =
b001000000 >
b001 ?
#1500000000
1!
1'
b0010 (
b10100000 )
1*
10
b0010 1
b10100000 2
13
b0010 7
b10100000 ;
b101000000 >
#2000000000
